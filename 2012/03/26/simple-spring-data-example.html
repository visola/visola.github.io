<!DOCTYPE html><html lang="en"><head><link href="https://visola.github.io/rss.xml" rel="alternate" type="application/rss+xml" title="Vinny's Blog"><link href="https://fonts.googleapis.com/css?family=Quattrocento:400,700|Droid+Sans+Mono" rel="stylesheet" type="text/css"><link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/bootstrap/3.3.5/css/bootstrap.min.css"><link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/highlight.js/8.9.1/styles/solarized_light.min.css"><link type="text/css" rel="stylesheet" href="/css/main.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-70095095-1', 'auto');
ga('send', 'pageview');</script><title>Vinny's Blog  - Simple Spring Data Example</title></head><body><div id="header"><a href="/"><img src="/img/me.jpg" class="me"></a><h2><a href="/">Vinny's Blog</a></h2><section class="links"><a href="http://twitter.com/IsolaVinicius"><img src="/img/twitter.png"></a><a href="http://stackoverflow.com/users/2731402/visola"><img src="/img/stackoverflow.png"></a><a href="https://github.com/visola/"><img src="/img/github.png"></a>&nbsp;&nbsp;<a href="/rss.xml"><img src="/img/rss.png"></a></section></div><div id="content"><h1>Simple Spring Data Example</h1><p class="published">Published on 2012-03-26</p><p>As my first post I&#39;m going to do a very simple command line application that manages one entity called Person. The purpose of this example is to demonstrate how powerful the new Spring Data projects family are.</p>
<!-- more -->
<h2 id="spring-data">Spring Data</h2>
<p>Spring Data is a family of projects that aims to create a repository layer. The idea is to have an abstract layer were all the dependencies will point to and different implementations with all kinds of data repositories (SQL and NoSQL), similiar to what JDBC did for SQL databases. So what you&#39;ll see when you go to Spring Data project page is one common project that has a bunch of interfaces and helper classes to deal with the abstraction of a repository - and here is where your dependencies should end. And then, a few other projects that implement this abstract layer for a specific data repository. Some examples are: JPA, Hadoop, etc.</p>
<p>A basic image of how the layers would be for the JPA Repository is this:</p>
<p><img src="/img/blog/spring-data-001.png" alt="Spring Data 001"></p>
<h2 id="the-example">The Example</h2>
<p>This example was meant to be as simple as possible. I&#39;m using spring data to provide the functionality required for a basic CRUD application using the JPA repository implementation. One thing worth noting is that though Spring Data will automatically do all the repository management for you, it&#39;s still necessary to map your entities. It is also necessary to setup your datasource and entity manager factory.</p>
<p>To avoid distractions, it will be just a command line application. The full source code can be found in the <a href="https://github.com/visola/bearprogrammer-examples">blog repository in github</a>.</p>
<p>So let&#39;s start by a basic step-by-step on what you need to setup to make everything work.</p>
<h3 id="step-1-create-a-datasource">Step 1 - Create a DataSource</h3>
<p>The simplest way to manage a DataSource is to let Spring do it for you. The following bean declaration uses Apache Commons DBCP connection pool to create a basic DataSource. This goes inside Spring configuration file (<code>/META-INF/spring/config.xml</code> for this application).</p>
<pre><code class="lang-xml">&lt;bean <span class="hljs-property">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-type">class</span>=<span class="hljs-string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="hljs-string">"close"</span>&gt;
    &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"driverClassName"</span> value=<span class="hljs-string">"org.h2.Driver"</span> /&gt;
    &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"url"</span> value=<span class="hljs-string">"jdbc:h2:~/databases/person"</span> /&gt;
    &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"username"</span> value=<span class="hljs-string">"sa"</span> /&gt;
    &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"password"</span> value=<span class="hljs-string">"sa"</span> /&gt;
&lt;/bean&gt;
</code></pre>
<p>This DataSource is using an embedded H2 database that is going to be created automatically inside the user directory inside a databases folder.</p>
<h3 id="step-2-create-your-entity">Step 2 - Create your entity</h3>
<p>I created one basic <code>Person</code> entity with a few properties and one named query that will be used to find a person by name (first or last). Setting first and last name to lower case inside the query will help make the query case insensitive (and slower if performance is an issue for you).</p>
<pre><code class="lang-java"><span class="hljs-keyword">package</span> bearprogrammer.blog.springdata.model;

<span class="hljs-comment">// imports here</span>

<span class="hljs-annotation">@Entity</span>
<span class="hljs-annotation">@NamedQuery</span>(
        name=<span class="hljs-string">"Person.findByName"</span>,
        query=<span class="hljs-string">"select p from Person p where lower(p.firstName) like ?1 or lower(p.lastName) like ?1"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> {</span>

    <span class="hljs-annotation">@Id</span>
    <span class="hljs-annotation">@GeneratedValue</span>
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String firstName;
    <span class="hljs-keyword">private</span> String lastName;
    <span class="hljs-keyword">private</span> String email;
    <span class="hljs-keyword">private</span> Calendar birthday;

    <span class="hljs-comment">// Getters and Setters</span>

}
</code></pre>
<h3 id="step-3-create-your-entitymanagerfactory">Step 3 - Create your EntityManagerFactory</h3>
<p>I&#39;ll use Spring&#39;s <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html . This is a [FactoryBean](http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/beans/factory/FactoryBean.html">LocalContainerEntityManagerFactoryBean</a> that generates <code>EntityManagerFactory</code> with specific configuration, avoiding any extra files to setup your persistence layer. That means we won&#39;t need a <code>persistence.xml</code> nor any other mapping files.</p>
<p>Inside Spring configuration file I added the following:</p>
<pre><code class="lang-xml">&lt;bean <span class="hljs-property">id</span>=<span class="hljs-string">"emf"</span> <span class="hljs-type">class</span>=<span class="hljs-string">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span>&gt;
    &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">"dataSource"</span> /&gt;
    &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"packagesToScan"</span> value=<span class="hljs-string">"bearprogrammer.blog.springdata.model"</span> /&gt;
    &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"persistenceProvider"</span>&gt;
        &lt;bean <span class="hljs-type">class</span>=<span class="hljs-string">"org.hibernate.ejb.HibernatePersistence"</span> /&gt;
    &lt;/<span class="hljs-keyword">property</span>&gt;
    &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"jpaProperties"</span>&gt;
        &lt;map&gt;
            &lt;entry key=<span class="hljs-string">"hibernate.dialect"</span> value=<span class="hljs-string">"org.hibernate.dialect.H2Dialect"</span> /&gt;
            &lt;entry key=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span> value=<span class="hljs-string">"update"</span> /&gt;
        &lt;/map&gt;
    &lt;/<span class="hljs-keyword">property</span>&gt;
&lt;/bean&gt;
</code></pre>
<p>All the JPA configuration happens in this bean declaration. The first property set where it will find the DataSource. That&#39;s the bean we declared on step 1. The second property, packagesToScan, set a list of packages that will be scanned for entities, in this case, I&#39;m setting only one, the one I put my entity in on step 2. The third property is the persistence provider, in this case, I&#39;m using Hibernate&#39;s provider.</p>
<p>The forth property is a map that will be passed to the provider for configuration. The first entry in the map is Hibernate&#39;s dialect, that&#39;s the one for H2 databases. The second entry requests Hibernate to update the database schema to match what&#39;s being mapped in the entities. If the schema doesn&#39;t exist, it will be created.</p>
<h3 id="step-4-create-your-repository-interface">Step 4 - Create your repository interface</h3>
<p>Spring Data will use your repository interface to manage all interaction with the underlying data repository (JPA in this example). In most cases, you won&#39;t need to implement any code, just use whatever Spring Data&#39;s implementation is given to you. The following is mine interface:</p>
<pre><code class="lang-java"><span class="hljs-keyword">package</span> bearprogrammer.blog.springdata.model;

<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> org.springframework.data.repository.PagingAndSortingRepository;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PagingAndSortingRepository</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">findByName</span><span class="hljs-params">(String name)</span></span>;

}
</code></pre>
<p>It has only one method declared and all others will be inherited from Spring Data&#39;s abstract repository interface.</p>
<p>Now that we have the repository interface, lets go to the last step:</p>
<h3 id="step-5-declare-the-repositories">Step 5 - Declare the repositories</h3>
<p>Spring Data JPA provides a specific namespace that contains one tag-do-all that will create the repository implementation for you. It&#39;s as simple as:</p>
<pre><code class="lang-xml">&lt;jpa:<span class="hljs-keyword">repositories</span> base-<span class="hljs-keyword">package</span>=<span class="hljs-string">"bearprogrammer.blog.springdata.model"</span> <span class="hljs-regexp">/&gt;</span>
</code></pre>
<p>The only thing you need to do is say what package your repository is in and it&#39;s done. The package - and subpackages - will be scanned for interfaces that extends <a href="http://static.springsource.org/spring-data/data-commons/docs/current/api/org/springframework/data/repository/Repository.html">Repository</a> and an implementation will be provided to you. If you don&#39;t specify the name of the bean, the name of the interface will be used. For example, the interface PersonRepository will create a bean named &#39;personRepository&#39; in the application context.</p>
<h2 id="detailed-explanation">Detailed Explanation</h2>
<p>When you declare methods in your repository interface, a query will be created automatically if you follow the pattern given by them - all the patterns can be found <a href="http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/#jpa.query-methods">here</a>. If you don&#39;t follow the pattern, like I didn&#39;t (because my entity doesn&#39;t have a property called &#39;name&#39;), it will try to map to a named query first. In this case, that will work because I have a named query that maps to my method name (my named query has the name &#39;Person.findByName&#39; and my &#39;<em>Person</em>Repository&#39; has a declared method &#39;findByName&#39;). If I didn&#39;t have the named query, an exception would be generated saying that the entity Person doesn&#39;t have a property called &#39;name&#39;.</p>
<p>The following is an image that represts what&#39;s going on:</p>
<p><img src="/img/blog/spring-data-002.png" alt="Spring Data 002"></p>
<p>Spring data will create a proxy that implements my &#39;PersonRepository&#39;. So for everyone that receives the bean created for the specific repository, it will be an implementation of that interface. It can also be autowired by type or name.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://static.springsource.org/spring-data/data-commons/docs/current/reference/html/">Spring Data Commons Reference</a></li>
<li><a href="http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/">Spring Data JPA Reference</a></li>
<li><a href="http://static.springsource.org/spring-data/data-commons/docs/current/api/">Spring Data API</a></li>
<li><a href="http://static.springsource.org/spring/docs/current/javadoc-api/">Spring API</a></li>
<li><a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/orm.html#orm-jpa">Spring Reference - ORM - JPA</a></li>
</ul>
</div><div id="footer"><section class="attribution">Windows 8 Vector Icon set by <a href="http://icons8.com/">Icons8</a></section></div></body></html>