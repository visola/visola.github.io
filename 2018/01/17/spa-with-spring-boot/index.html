<!DOCTYPE html><html lang="en"><head><link href="https://visola.github.io/rss.xml" rel="alternate" type="application/rss+xml" title="Vinny's Blog"><link href="https://fonts.googleapis.com/css?family=Lato:300,700|Droid+Sans+Mono" rel="stylesheet" type="text/css"><link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/bootstrap/3.3.5/css/bootstrap.min.css"><link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/highlight.js/8.9.1/styles/solarized_light.min.css"><link type="text/css" rel="stylesheet" href="/css/main.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-70095095-1', 'auto');
ga('send', 'pageview');</script><title>Vinny's Blog  - SPA with Spring Boot</title><link rel="canonical" href="/2018/01/17/spa-with-spring-boot/index.html"></head><body><div id="header"><a href="/"><img src="/img/me.jpg" class="me"></a><h2><a href="/">Vinny's Blog</a></h2><section class="links"><a href="http://twitter.com/IsolaVinicius"><img src="/img/twitter.png"></a><a href="http://stackoverflow.com/users/2731402/visola"><img src="/img/stackoverflow.png"></a><a href="https://github.com/visola/"><img src="/img/github.png"></a>&nbsp;&nbsp;<a href="/rss.xml"><img src="/img/rss.png"></a></section></div><div id="content"><h1>SPA with Spring Boot</h1><p class="published">Published on 2018-01-17 by Vinicius Isola</p><p>Single page applications are becoming more and more common these days. If you work with Spring Boot and want to build your frontend using this architecture, you have two options: build the frontend on a separate repository and serve it using some HTTP server or serve your files from your Java application.</p>
<p>This post explains the basic configuration needed so that you can manage routing on the frontend and still serve your static files from your Java/Spring application.</p>
<!-- more -->
<p>The sample code for this application lives <a href="https://github.com/visola/bearprogrammer-examples/tree/master/spa-with-spring-boot">here</a>.</p>
<h2 id="api-base">API Base</h2>
<p>The first step you need to do is decide where your APIs will live and settle on a base path for them. I normally just use <code>api/v1</code> as the base path but use a variable in <code>application.yml</code> to get it.</p>
<p>Inside <code>src/main/resources/applcation.yml</code> I just set:</p>
<pre><code class="lang-yml">api<span class="hljs-class">.base</span><span class="hljs-class">.path</span>: /api/v1
</code></pre>
<p>And then, in my controllers, I always use a relative path passing in that variable as the base:</p>
<pre><code class="lang-java"><span class="hljs-annotation">@RequestMapping</span>(<span class="hljs-string">"<span class="hljs-subst">${api.base.path}</span>/messages"</span>)
<span class="hljs-annotation">@RestController</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>{

    <span class="hljs-annotation">@ResponseBody</span>
    <span class="hljs-annotation">@RequestMapping</span>(<span class="hljs-string">"/{name}"</span>)
    public HelloVO getMessage(<span class="hljs-annotation">@PathVariable</span> <span class="hljs-built_in">String</span> name) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloVO(name);
    }

}
</code></pre>
<h2 id="always-redirect-to-index-html-">Always redirect to <code>index.html</code></h2>
<p>In a single page application, routing is normally handled by code in the frontend. If you&#39;re using Backbone, React, Angular, all provide some kind of routing framework and they all expect that the main javascript entry point will be loaded, doesn&#39;t matter what route you load your app from.</p>
<p>Because of that, when your application is loaded from <code>/</code> or from <code>/some/path</code>, you need to load your <code>index.html</code>, call the router and decide what page the user should see. To make that work in Spring, you need to add a <code>ResourceResolver</code> that will always load the root page as long as you&#39;re not asking for a resource (stylesheet, image, font, etc.) or making an API call.</p>
<p>This is how that code looks like (in <code>src/main/java/org/visola/springbootspa/config/WebConfiguration.java</code>):</p>
<pre><code class="lang-java"><span class="hljs-annotation">@Configuration</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfiguration</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">WebMvcConfigurerAdapter</span> {</span>
  ...

  <span class="hljs-annotation">@Override</span>
    public void addResourceHandlers(<span class="hljs-type">ResourceHandlerRegistry</span> registry) {
      <span class="hljs-comment">// All resources go to where they should go</span>
      registry
        .addResourceHandler(<span class="hljs-string">"/**/*.css"</span>, <span class="hljs-string">"/**/*.html"</span>, <span class="hljs-string">"/**/*.js"</span>, <span class="hljs-string">"/**/*.jsx"</span>, <span class="hljs-string">"/**/*.png"</span>, <span class="hljs-string">"/**/*.ttf"</span>, <span class="hljs-string">"/**/*.woff"</span>, <span class="hljs-string">"/**/*.woff2"</span>)
        .setCachePeriod(<span class="hljs-number">0</span>)
        .addResourceLocations(<span class="hljs-string">"classpath:/static/"</span>);

      registry.addResourceHandler(<span class="hljs-string">"/"</span>, <span class="hljs-string">"/**"</span>)
        .setCachePeriod(<span class="hljs-number">0</span>)
        .addResourceLocations(<span class="hljs-string">"classpath:/static/index.html"</span>)
        .resourceChain(<span class="hljs-literal">true</span>)
        .addResolver(<span class="hljs-keyword">new</span> <span class="hljs-type">PathResourceResolver</span>() {
          <span class="hljs-annotation">@Override</span>
          <span class="hljs-keyword">protected</span> <span class="hljs-type">Resource</span> getResource(<span class="hljs-type">String</span> resourcePath, <span class="hljs-type">Resource</span> location) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> {
            <span class="hljs-keyword">if</span> (resourcePath.startsWith(baseApiPath) || resourcePath.startsWith(baseApiPath.substring(<span class="hljs-number">1</span>))) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }

            <span class="hljs-keyword">return</span> location.exists() &amp;&amp; location.isReadable() ? location : <span class="hljs-literal">null</span>;
          }
        });
    }

}
</code></pre>
<p>There are two important things happening here:</p>
<ol>
<li>The first resource handler will match any font, stylesheet or image in the coming from the <code>static</code> folder from the classpath. Those we definitely don&#39;t want to redirect to <code>index.html</code></li>
<li>The second resource handler matches everything else that is not mapped to a controller or something else using <code>@RequestMapping</code>. This resource handler will check if the path was an API call and it fails if it was (because we want to return 404 and not 200 with <code>index.html</code> as the body for API path typos).</li>
</ol>
<p>One detail here is that I&#39;m setting the cache period to zero, which means that it will never cache nor send cache headers for these resources. If you&#39;re using caching and generating some type of bundle version like using the <code>chunkhash</code> from <a href="https://webpack.js.org/guides/caching/">Webpack caching</a>, then you should set that up to a very long time for your first handler, probably <code>Integer.MAX_VALUE</code>. That way your resources will be cached forever and the browser will never reload them, but it will automatically pick a new version from <code>index.html</code>.</p>
</div><div id="footer"><section class="attribution">Windows 8 Vector Icon set by <a href="http://icons8.com/">Icons8</a></section></div></body></html>