<!DOCTYPE html><html lang="en"><head><link href="https://fonts.googleapis.com/css?family=Hind+Siliguri:600,300|Droid+Sans+Mono" rel="stylesheet" type="text/css"><link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/bootstrap/3.3.5/css/bootstrap.min.css"><link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/highlight.js/8.9.1/styles/solarized_light.min.css"><link type="text/css" rel="stylesheet" href="/css/main.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-70095095-1', 'auto');
ga('send', 'pageview');</script><title>Welcome to Vinny's Blog</title></head><body><div id="content"><h2><a name="Testing a web application with Gretty, Cucumber and Selenium" href="2014/09/03/Testing a web application with Gretty, Cucumber and Selenium.html">Testing a web application with Gretty, Cucumber and Selenium</a></h2><p class="published">Published on 2014-09-03</p><p>The code used in this post is a complete web application built with Spring WebMVC, Spring Data and Spring Security. It contains a lot more than what is explained here and I hope to come back to it in later posts. The code can be found in my <a href="https://github.com/visola/bearprogrammer-examples/tree/master/complete-to-do">Github repository</a>.</p>
<p>For this post I&#39;ll be focusing on how you can test a web application using Cucumber and Selenium. I&#39;ll be using the <a href="https://github.com/akhikhl/gretty/">Gretty</a> plugin to start a web container during the build. I&#39;ve picked this plugin because of the built-in setup for integration tests.</p>
<h2><a name="Building with Gradle" href="2014/05/18/Building with Gradle.html">Building with Gradle</a></h2><p class="published">Published on 2014-05-18</p><p>Gradle is a build system that was build from the lessons learned from Ant and Maven. Similarly with Ant, where you have a XML namespace to write build scripts, Gradle is a <a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> on top of Groovy that helps you write build scripts. But it goes further with many plugins and conventions (like Maven) that make it possible to get a build up and running with just a few lines of Groovy.</p>
<p>A Gradle build starts with a <code>build.gradle</code> file. This file contains plugins that you apply to your build, dependencies that your project need to compile, package and run, repositories where your dependencies will be loaded from, plugin configurations and custom tasks. All those are written with a cleverly build model that makes your build scripts readable, maintainable and easy to extend.</p>
<p>In this post I&#39;ll cover the gradle build from the three sample projects that I worked on to compare the <a href="http://bearprogrammer.com/2013/12/17/build-tools-for-java">three mainstream Java build tools</a>. The code for this post can be found in my <a href="https://github.com/visola/bearprogrammer-examples/tree/master/build-tools/sample-gradle">github repository</a>.</p>
<h2><a name="Building with Ant" href="2014/03/22/Building with Ant.html">Building with Ant</a></h2><p class="published">Published on 2014-03-22</p><p>Ant has been around for a while now (first released in 2000) and it can be compared with a scripting language written in XML. XML tags are translated to Java objects and executed calling methods in the objects created. The following image illustrates the relationship between the XML and the Java objects:</p>
<p><img src="/img/blog/ant-xml-to-java.png" alt="Ant xml to java"></p>
<p>A project built with Ant begins with a <code>build.xml</code> file where you describe all targets. A target is a set of tasks and can depend on other targets. When you run an Ant build, you tell it what target you want to execute. Ant then creates a target dependency tree for your project, calculates the least amount of targets necessary to get to the requested target and starts executing them from the target that has no dependencies. The build is considered finished when the requested target gets executed or some target failed.</p>
<p>In this post I&#39;ll explain the two things that I found not so well documented and lacking clear explanation on how to do it: dependency management and code coverage measurement with Jacoco. This was part of the project that I worked on to compare the <a href="http://bearprogrammer.com/2013/12/17/build-tools-for-java/&quot;" title="Build tools for Java">three mainstream Java build tools</a>. The code for this post can be found in my <a href="https://github.com/visola/bearprogrammer-examples/tree/master/build-tools/sample-ant">github repository</a>.</p>
<h2><a name="Build tools for Java" href="2013/12/17/Build tools for Java.html">Build tools for Java</a></h2><p class="published">Published on 2013-12-17</p><p>More than a year ago <a href="/2012/06/03/Beginning with Maven and M2.html" title="Beginning with Maven and M2">I wrote a post about</a> how I started to use Maven to build my Java applications and how much I loved it! Things changed a lot since then and I, like many others, am moving my projects to <a href="http://www.gradle.org">Gradle</a>. In this post - and a few more to come - I&#39;ll be talking about build tools for Java and make some comparisons and explain why I moved to Gradle.</p>
<p>This content started from a recent presentation that I gave at work about build tools. The idea was to make a comparison between the three most widespread build tools for Java: <a href="http://ant.apache.org/">Ant</a>, <a href="http://maven.apache.org/">Maven</a> and Gradle. I thought it would be cool to have a project - simple but with some complex dependencies - built using all three of them. With that it would be easy to compare, apples to apples, how each one works and what are the advantages and disadvantages of each one.</p>
<h2><a name="DAO, Repository and Service, digging deeper" href="2012/11/12/DAO, Repository and Service, digging deeper.html">DAO, Repository and Service, digging deeper</a></h2><p class="published">Published on 2012-11-12</p><p>The first time I heard the term <em>service layer</em> I was intrigued by it because I always used a <em>Data Access Object</em> to access  my data. I thought it was just a <em>new way to refer to the same thing</em>. Of course I was wrong. A couple of years later I started to use Spring Data and again I was confronted with the <em>Repository</em> a <em>different name for the same thing</em>, at least that was what I thought, and again, I was wrong.</p>
<p>I&#39;m not the kind of person that settles down until I get a complete answer for the problem, I really hate when I don&#39;t have a precise and detailed answer. That&#39;s why I decided to take some time and research deeper and write down my findings for all of you that are thinking the same way and get lost every time you need to name your data access layer objects.</p>
<p>Some may say: <em>How can you get confused about something that is clearly different?</em> If you think that, then this post is not for you, unless you want to help me review my content (what I would appreciate). But if you&#39;re like me and have been writing small (10-15 model classes) web applications you&#39;re probably standing where I am: your <em>data layer</em> has some characteristics of all three patterns.</p>
</div></body></html>